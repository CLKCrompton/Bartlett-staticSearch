<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns="http://www.tei-c.org/ns/1.0"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Project Endings staticSearch Generator</title>
        <author><name>Martin Holmes</name></author>
        <author><name>Joey Takeda</name></author>
      </titleStmt>
      <publicationStmt>
        <publisher>University of Victoria Humanities Computing and Media Centre</publisher>
        <availability><licence>Free to anyone for any purpose</licence></availability>
      </publicationStmt>
      <sourceDesc>
        <p>Born-digital document</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <front>
      <titlePage>
        <docTitle>
          <titlePart type="main">Project Endings staticSearch Generator</titlePart>
          <titlePart type="sub">Schema and guidelines for creating a staticSearch engine for your HTML5 site</titlePart>
        </docTitle>
        <docAuthor>Martin Holmes</docAuthor>
        <docAuthor>Joey Takeda</docAuthor>
        <docDate>2019-2020</docDate>
      </titlePage>
      <p>This documentation provides instructions on how to use the Project Endings
        staticSearch Generator to provide a fully-functional search <soCalled>engine</soCalled>
        to your website without any dependency on server-side code such as a database.</p>
      <divGen type="toc"/>
    </front>
    <body>
        <head>Project Endings staticSearch Generator</head>
        <div xml:id="whatDoesItDo">
          <head>What does it do?</head>
          <list>
            <item>Level: Basic</item>
            <item>Last Updated: <date when="2020-10-14">14 October 2020</date></item>
          </list>
          <p>The generator tool processes your site to create an index of all the words appearing
          in the site, stemmed (if desired) using a stemmer, and stores the index in the 
          form of a
          large number of small JSON files. It also creates JSON files for other search facets that 
          you specify in the headers of your documents, to allow searches for documents by 
          type, by date range, and so on. Then it creates a search page for your site, which 
          processes user search terms and retrieves the required JSON files to provide search results.</p>
          <p>You can see several examples of sites and projects which use staticSearch in 
            <ref target="#projectsUsingSS">Projects using staticSearch</ref>.</p>
          
        </div>
      <div xml:id="whyWouldIUseIt">
        <head>Why would I use it?</head>
        <list>
          <item>Level: Basic</item>
          <item>Last Updated: <date when="2020-05-08">8 May 2020</date></item>
        </list>
        <p>Digital Humanities projects such as digital editions of historical and literary texts are typically the work of teams of people collaborating over many years, and the fruit of their labours deserves to have a significant shelf-life, if possible comparable with that of a traditional print publication. However, digital longevity of DH projects is sadly short, and many disappear or cease to function within a few years of their creation, because of their dependency on transient tools and technologies.</p> 
        
        <p>However, static websites (websites which consist entirely of HTML, CSS and JavaScript, without any dependency on back-end server systems such as databases or PHP processing) are far more resilient in the long term than sites which use more server-side technology, and are also much easier to archive and replicate (see Holmes and Takeda (2019), <ref target="https://zenodo.org/record/3449197">The Prefabricated Website: Who needs a server anyway?</ref>). For this reason, the <ref target="https://projectendings.github.io/">Project Endings</ref> team have been developing and publicizing strategies for moving digital projects to an all-static publication model. The most problematic component in the all-static approach is search.</p>
        
        <p>Most digital publications take one of two approaches to search: either they have their own back-end database search engine (perhaps Solr or an XML database), or they rely on commercial services such as Google (which may be free, but are still beyond the control of the project team). DH projects need sophisticated options for searching, but typically this requires the use of technologies that may become obsolete or unsupported, or services which may change their terms of use or become unavailable.</p>
        
        <p>staticSearch solves this problem. It provides the capability to build a sophisticated faceted search engine into your website without the need for any back-end services at all (except of course for a web server, which you need anyway).</p>
        
      </div>
      
        <div xml:id="textSearchFeatures">
          <head>Text search features</head>
          <list>
            <item>Level: Intermediate</item>
            <item>Last Updated: <date when="2020-07-03">3 July 2020</date></item>
          </list>
          <p>The Generator supports the following features:</p>
          <list>
            <item>Stemming of terms (so searching for <q>wait</q> will also
            retrieve <q>waiting</q>, <q>waits</q>, <q>waited</q> etc.). Our default stemmer
            is the English Porter 2 stemmer, but if you have documents in another language, you can create
            and plug in <ref target="#stemmerFolder">your own stemmer</ref>.</item>
            <item>Boolean search operators. Adding <code>+</code> (plus) before a word means that
            search results <emph>must contain</emph> that word, and adding a <code>-</code> (minus) means
            that results <emph>must not contain</emph> that word. Words without plus or minus are treated
            as <emph>may contain</emph>, contributing to the score of any retrieved document.</item>
            <item>Phrasal searches. Any quoted phrase will be searched as-is, and when quoted phrases 
            are included in a search, any hit document must contain at least one of them. Note that phrasal
            search support requires a specific setting in your configuration file, because it increases the
            size of the index.</item>
            <item>Keyword-in-context search results. This is also configurable, since including contexts
            increases the size of the index.</item>
            <item>Wildcard searches, using the asterisk (*), question mark (?) and character
            classes ([ab]). So you can search for <code>lo[uv]e?</code> to find <q>loved</q>,
              <q>loued</q>, <q>loves</q>, <q>louer</q>, etc. If you don't have a stemmer for 
            the language of your document collection, this feature is a good alternative (although
            it can be combined with a stemmer as well for greater flexibility).</item>
            <item>Search filtering using any metadata you like, allowing users to limit their 
              search to specific
            document types, date ranges, or other features.</item>
          </list>
        </div>
      <div xml:id="searchFacetFeatures">
        <head>Search facet features</head>
        <list>
          <item>Level: Basic</item>
          <item>Last Updated: <date when="2020-02-20">20 February 2020</date></item>
        </list>
        <p>The Generator supports the following search facets:</p>
        <list>
          <item><term>Descriptors</term>. You might for example classify your documents as poems, 
          short stories and novels; the user can then choose to search in only poems, or poems and short stories.</item>
          <item><term>Date ranges</term>. You might assign each document a date (or a date range) for its first 
          publication and another for its last publication; then users could search for documents first published in a certain
          date range and last published before another date.</item>
          <item><term>Number ranges</term>. Similar to date ranges, you can assign a number to
          each document and then filter the search on a subrange of those numbers. For example, 
          a collection of poems might be filtered on the number of stanzas, so users could
          find all two-stanza poems or all poems with three or more stanzas.</item>
          <item><term>Booleans</term> (true/false values). You might for instance specify that some poems are 
          illustrated while others are not. The user could then limit their search only to illustrated poems.</item>
        </list>
      </div>
      
      <div xml:id="howDoIGetIt">
        <head>How do I get it?</head>
        <list>
          <item>Level: Basic</item>
          <item>Last Updated: <date when="2020-01-13">13 January 2020</date></item>
        </list>
        <p>There are two ways to get the staticSearch code. The first is to download a release package from 
          the <ref target="https://github.com/projectEndings/staticSearch/releases/">project release page</ref>;
        we recommend that you get the latest version. You can download a zip file and unzip it to create a 
        folder containing the code.</p>
        <p>The second way to get the codebase is to clone it from the 
          <ref target="https://github.com/projectEndings/staticSearch">GitHub repository</ref>. If you're doing 
        this, you can clone either the current master branch, the last release tag, or the dev branch. If you 
        clone the dev branch, bear in mind that you're working with development code and things may break.</p>
      </div>
        <div xml:id="howDoIUseIt">
          <head>How do I use it?</head>
          <list>
            <item>Level: Intermediate</item>
            <item>Last Updated: <date when="2020-12-18">18 December 2020</date></item>
          </list>
          <p>First, you will have to make sure your site pages are correctly configured so that the Generator can
          parse them. Then, you will have to create a configuration file specifying what options you want to use. 
          Then you run the generator, and the search functionality should be added to your site.</p>
          
            <p>The generator is expecting to parse <emph>well-formed XHTML5 web pages</emph>. That means
            web pages which are well-formed XML, using the XHTML namespace. If your site is just raggedy tag-soup,
            then you can't use this tool. You can tidy up your HTML using 
              <ref target="http://www.html-tidy.org/">HTML Tidy</ref>.</p>
          
          <div>
            <head>Configuring your site: search filters</head>
            <p>Next, you will need to decide whether you want search filters or not. If you want to allow
            your users to search (for example) only in poems, or only in articles, or only in blog posts, or 
            any combination of these document types, you will need to add <gi>meta</gi> tags to the heads of
            your documents to specify what these filters are. <title level="m">staticSearch</title> supports 
            four filter types.</p>
            
            <div xml:id="descFilters">
              <head>Description filters</head>
              <p>
              The description (desc) filter is a word or phrase describing or associated with the document.
              Here is a simple example:
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Document type" class="staticSearch.desc" content="Poems" />
              </egXML>
              
              This specifies that there is to be a descriptive search filter called <q>Document type</q>, and one of the
              types is <q>Poems</q>; the document containing this <gi>meta</gi> tag is one of the Poems. Another
              type might be:
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Document type" class="staticSearch.desc" content="Short stories" />
              </egXML>
              
              If the Generator finds such meta tags when it is indexing, it will create a set of filter controls
              on the search page, enabling the user to constrain the search to a specific set of filter settings.
            </p>
              
              <div xml:id="descFilterSorting">
                <head>Sort order for description filters</head>
                
                <p>Description filter labels may be plain text such as <q>Short stories</q> or <q>Poems</q>, but
                they may also be more obscure labels relating to document categories in indexing systems or 
                archival series identifiers. When the search page is generated, these labels are turned into
                a series of labelled checkboxes, sorted in alphabetical order. However, the strict alphabetical order
                of items may not be exactly what you want; you may want to sort <q>305 2</q> before <q>305 10</q>
                for example. To deal with cases like this, in addition to the <att>content</att> attribute, you 
                can also supply a custom <att>data-ssfiltersortkey</att> attribute, providing a sort key for
                each label. Here is are a couple of examples:
                
                  <egXML xmlns="http://www.tei-c.org/ns/Examples">
                    <meta name="Archival series" class="staticSearch.desc" data-ssfiltersortkey="305_02" content="305 2" />
                    <meta name="Archival series" class="staticSearch.desc" data-ssfiltersortkey="305_10" content="305 10" />
                  </egXML>
                  
                  In this case, the first item will sort in the filter list before the second item based on the sort 
                  key; without it, they would sort in reverse order based on the <att>content</att> attribute. Note that
                  the <att>data-ssfiltersortkey</att> attribute name is all-lower-case, to comply with the  XHTML5 schema.
                
                </p>
                
              </div>
            </div>
            
            
            <div xml:id="dateFilters">
              <head>Date filters</head>
            <p>Another slightly different kind of search control is a document date. If your collection of 
            documents has items from different dates, you can add a <gi>meta</gi> tag like this:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Date of publication" class="staticSearch.date" content="1895-01-05" />
              </egXML>
              
              The date may take any of the following forms:
              
              <list>
                <item>1895 (year only)</item>
                <item>1895-01 (year and month)</item>
                <item>1895-01-05 (year, month and day)</item>
              </list>
              
              For some documents, it may not be possible to specify a single date in this form,
              so you can specify a range instead, using a slash to separate the start and end
              dates of the range (following ISO 8601):
              
              <list>
                <item>1895/1897</item>
               <item>1903-01-02/1905-05-31</item>
              </list>
            </p>
            </div>
            
            <div xml:id="numFilters">
              <head>Number filters</head>
            
            <p>You can also configure a range filter based on
            a numeric value (integer or decimal). For example, you might want to allow
            people to filter documents in the search results based on their word-count:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Word-count" class="staticSearch.num" content="2193" />
              </egXML>
              
              Users would then be able to set a minimum and/or maximum word-count when
              searching for documents.
            </p>
            
            </div>
            
            <div xml:id="boolFilters">
              <head>Boolean filters</head>
            
            <p>A fourth filter type is the boolean (true/false) filter. To use boolean filters, add meta tags like this
            to your documents:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="Peer-reviewed" class="staticSearch.bool" content="true" />
              </egXML>
            
            </p>
            </div>
          </div>
          
          <div xml:id="configuringDocTitles">
            <head>Configuring your site: document titles</head>
            
            <p>When the indexing process runs over your document collection, by default it will use the document
            title that it finds in the <gi>title</gi> element in the document header; that title will then be 
            shown as a link to the document when it comes up in search results. However, that may not be the ideal
            title for this purpose; for example, all of your documents may include the site title as the first part
            of their document title, but it would be pointless to include this in the search result links. Therefore
            you can override the document title value by providing another meta tag, like this:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="docTitle" class="staticSearch.docTitle" content="What I did in my holidays" />
              </egXML>
            
            </p>
          </div>
          
          <div xml:id="configuringDocSortKey">
            <head>Configuring your site: document sort keys</head>
            
            <p>When a user searches for text on your site, the documents
              retrieved will be presented in a sequence based on the 
              <soCalled>hit score</soCalled> or <soCalled>relevance
                score</soCalled>; documents with the highest scores will
              be presented first, and the list will be in descending
              order of relevance. However, if you have search filters on
              your site, it is possible that users will not enter any 
              search text at all; they may simply select some filters 
              and get a list of matching documents. In this case, there
              will be no relevance scores, so the documents will be 
              presented in a random order. However, you may wish to 
              control the order in which documents without hit scores, 
              or sequences of documents with the same hit score, are
              presented. You can do this by adding a single meta tag
              to the document providing a <soCalled>sort key</soCalled>,
              which can be used to sort the list of hits. This is an 
              example:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="ssDocSortKey" content="d_1854-01-02" />
              </egXML>
            </p>
          </div>
          
          <div xml:id="configuringDocThumbnails">
            <head>Configuring your site: document thumbnails</head>
            
            <p>When a document is returned as a result of a search hit, you may want to include with it
            a thumbnail image. This may be for aesthetic reasons, or because the focus of the document
            itself is actually an image (perhaps your site is a set of pages dealing with works of art, for
            instance). Whatever the reason, you can supply a link to a thumbnail image like this:
            
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <meta name="docImage" class="staticSearch.docImage" content="images/thisPage.jpg" />
              </egXML>
            
            The <att>content</att> attribute value should either be the path to an image relative to the 
              document itself or the URL to an external image; so in the example above, there would be a folder called <ident>images</ident>
              which is a sibling of the HTML file containing the tag, and that folder would contain a file
              called <ident>thisPage.jpg</ident>.
            
            </p>
            
          </div>
          
          <div xml:id="creatingConfigFile">
            <head>Creating a configuration file</head>
            
            <p>The configuration file is an XML document which tells the Generator where to find your site,
            and what search features you would like to include. The configuration file conforms to a schema which is
            documented here.</p>
            <p>There are three main sections of the configuration file:
              <list>
                <item><gi>params</gi></item>
                <item><gi>rules</gi></item>
                <item><gi>contexts</gi></item>
              </list>
              Only the <gi>params</gi> element is necessary, but, as we discuss shortly, we highly suggest taking advantage of the <gi>rules</gi>
              and <gi>contexts</gi> for the best results.
            </p>
            
            
            <div xml:id="specifyingParameters">
              <head>Specifying parameters</head>
              <div xml:id="paramsRequired">
                <head>Required parameters</head>
                <p>The <gi>params</gi> element has two required elements for determining the resource collection that you wish to index:
                  <list>
                    <item><gi>searchFile</gi></item>
                    <item><gi>recurse</gi></item>
                  </list>
                </p>
                <p>The <gi>searchFile</gi> element is a relative URI (resolved, like all URIs specified in the config file, against the configuration file location) that points
                  directly to the search page that will be the primary access point for the search. Since the search file must be at the root of the directory that you wish to index
                  (i.e. the directory that contains all of the XHTML you want the search to index), the searchFile parameter provides the necessary information for knowing 
                  what document collection to index and where to put the output JSON. In other words, in specifying the location of your search page, you are also 
                  specifying the location of your document collection. See <ref target="#searchPage">Creating a search page</ref> for more information on how to configure this file.</p>
                <p>Note that all output files will be in a directory that is a sibling to the search page. For instance, in a document collection that looks something like:
                  <list style="font-family: monospace">
                    <item>myProject
                      <list>
                        <item>novel.html</item>
                        <item>poem.html</item>
                        <item>shortstory.html</item>
                        <item>search.html</item>
                      </list>
                    </item>
                  </list>
                  The collection of Javascript and JSON files will be in a directory like so:
                  <list style="font-family: monospace">
                    <item>myProject
                      <list>
                        <item>novel.html</item>
                        <item>poem.html</item>
                        <item>shortstory.html</item>
                        <item>search.html</item>
                        <item><emph>staticSearch</emph></item>
                      </list>
                    </item>
                  </list>
                </p>
                <p>We also require the <gi>recurse</gi> element in the case where the document collection may be nested (as is common with static sites generated from Jekyll or Wordpress). The <gi>recurse</gi> element is a boolean (true or false) that determines whether or not to recurse into the subdirectories of the collection and index those files.</p>
              </div>
              
              <div xml:id="paramsOptional">
                <head>Optional parameters</head>
                <p>The following parameters are optional, but most projects will want to specify 
                some of them:</p>
                <list>
                  <item><gi>versionFile</gi> enables you to specify the path to a plain-text file
                  containing a simple version number for the project. This might take the form of 
                  a software-release-style version number such as <val>1.5</val>, or it might be
                  a Subversion revision number or a Git commit id. It should not contain any 
                  spaces or punctuation. If you provide a version file, the version string will
                  be used as part of the filenames for all the JSON resources created for the 
                  search. This is useful because it allows the browser to cache such resources 
                  when users repeatedly visit the search page, but if the project is rebuilt with 
                  a new version, those cached files will not be used because the new version will
                  have different filenames. The path specified is relative to the location of the
                  configuration file (or absolute, if you wish).</item>
                  
                  <item><gi>phrasalSearch</gi> is a boolean parameter which specifies whether you 
                  want your search engine to support phrasal searches (quoted strings). Obviously this
                  is a useful feature, but it is also costly in terms of the size of JSON token files; 
                  in order to support this kind of search, we store contexts for all hits for each token
                  in each document, so if your site is very large, and your user base is unlikely to 
                  use phrasal searching, it may not be worth the overhead. The default value is true.</item>
                  
                  <item xml:id="stemmerFolder">
                    <gi>stemmerFolder</gi> is a string parameter specifying the name
                    of a folder that is inside the <ident>/stemmers/</ident> folder in
                    the staticSearch repository structure.
                    
                    <p>The staticSearch project currently has only one real stemmer,
                      an implementation of the Porter 2 algorithm for modern English. That 
                      appears in <ident>/stemmers/en/</ident>, so the default value for
                      this parameter is <val>en</val>. We will
                      be adding more stemmers as the project develops. However, if your 
                      document collection is not English, you have a couple of options, one 
                      hard and one easy.
                      
                      <list>
                        <item><emph>Hard option</emph>: implement your own stemmers. You will need to
                          write two implementations of the stemmer algorithm, one in XSLT (which 
                          must be named <ident>ssStemmer.xsl</ident>) and one in JavaScript
                          (<ident>ssStemmer.js</ident>), and confirm that they both generate the
                          same results. The XSLT stemmer is used in the generation of the 
                          index files at build time, and the JavaScript version is used to 
                          stem the user's input in the search page. You can look at the 
                          existing implementations in the <ident>/stemmers/en/</ident> folder
                          to see how the stemmers need to be constructed. Place your stemmers
                          in a folder called <ident>/stemmers/[yourlang]/</ident>, and 
                          specify <val>yourlang</val> in the configuration file.
                        </item>
                        <item><emph>Easy option</emph>: Use the <ident>identity stemmer</ident>
                          (which is equivalent to turning off stemming completely), and 
                          make sure wildcard searching is turned on. Then your users can 
                          search using wildcards instead of having their search terms 
                          automatically stemmed. To do this, specify the value <val>identity</val>
                          in your configuration file.
                        </item>
                      </list>
                      Another alternative is the <ident>stripDiacritics</ident> stemmer. Like the
                      <ident>identity stemmer</ident>, this is not really a stemmer at all; 
                      what it does is to 
                      strip out all combining diacritics from tokens. This is a useful approach
                      if you document collection contains texts with accents and diacritics, but 
                      your users may be unfamiliar with the use of diacritics and will want to
                      search just with plain unaccented characters. For example, if a text contains
                      the word <mentioned>élève</mentioned>, but you would like searchers to be able to
                      find the word simply by typing the ascii string <mentioned>eleve</mentioned>, then this
                      is a good option. Combined with wildcards, it can provide a very flexible and
                      user-friendly search engine in the absence of a sophisticated stemmer, or for
                      cases where there are mixed languages so a single stemmer will not do. To 
                      use this option, specify the value <val>stripDiacritics</val>
                      in your configuration file.
                    </p>
                  </item>
                  <item><gi>scoringAlgorithm</gi> is an optional element that specifies which 
                    scoring algorithm to use when calculating the score of a term and thus the order
                    in which the results from a search are sorted. There are currently two options:
                  <list>
                    <item><val>raw</val>: This is the default option (and so does not need 
                      to be set explicitly). The raw score is simply the sum of all instances of a term 
                      (optionally multipled by a configured weight via the
                      <gi>rule</gi>/<att>weight</att> <ref target="#specifyingRules">configuration</ref>) in a document. This will usually provide good
                      results for most document collections.</item>
                    <item><val>tf-idf</val>: The tf-idf algorithm (term frequency-inverse document frequency)
                      computes the mathematical relevance of a term within a document relative to the rest
                      of the document collection. The staticSearch implementation of tf-idf basically follows the textbook definition of tf-idf:
                      <formula style="display:block;">
                        tf-idf = ($instancesOfTerm / $totalTermsInDoc) * log( $allDocumentsCount / $docsWithThisTermCount )
                      </formula>
                      This is fairly crude compared to other search engines, like <ref target="https://lucene.apache.org/core/3_5_0/scoring.html">Lucene</ref>, but it may provide useful results
                    for document collections of varying lengths or in instances where the raw score may be
                    insufficient or misleading. There are a number of resources on tf-idf
                    scoring, including: <ref target="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">Wikipedia</ref> and Christopher D. Manning, Prabhakar Raghavan and Hinrich Schütze, <ref target="https://nlp.stanford.edu/IR-book/html/htmledition/tf-idf-weighting-1.html">Introduction to Information Retrieval</ref>, Cambridge University Press. 2008.</item>
                  </list>
                  </item>
                  <item><gi>createContexts</gi> is a boolean parameter that specifies whether you 
                  want the indexer to store keyword-in-context extracts for each of the hits in a
                  document. This increases the size of the index, but of course it makes for much 
                  more user-friendly search results.</item>
                  
                  <item><gi>maxKwicsToHarvest</gi> controls the number of keyword-in-context extracts
                  that will be harvested from the data for each term in a document. If you set this to
                  a low number, the size of the JSON files will be constrained, but of course the 
                  user will only be able to see the KWICs that have been harvested in their search results.</item>
                  
                  <item><gi>maxKwicsToShow</gi> controls the number of keyword-in-context extracts
                    that will be shown in the search results for each hit document. </item>
                  
                  <item><gi>totalKwicLength</gi> is an integer specifying how long a keyword-in-context
                  string should be. Obviously, the higher this number is, the larger the individual index
                  files will be, but the more useful the KWICs will be for users looking at the search results.</item>
                  
                  <item><gi>kwicTruncateString</gi> is a string containing the character you would like
                  to use at the beginning and/or the end of a kwic which is not a full sentence. An 
                  ellipsis character is the default.</item>
                  
                  <item><gi>linkToFragmentId</gi> is a boolean parameter that specifies whether you want
                    the search engine to link each keyword-in-context extract with the closest element that 
                    has an <att>id</att>. If the element has an ancestor with an <att>id</att>, then the indexer will associate
                    that keyword-in-context extract with that <att>id</att>; if there are no suitable ancestor elements that have
                    an <att>id</att>, then the extract is associated with first preceding element with an <att>id</att>.
               </item>
                  
                  <item><gi>scrollToTextFragment</gi> (WARNING: experimental feature). 
                    Google has proposed a browser feature called <ref target="https://wicg.github.io/scroll-to-text-fragment/">Text Fragments</ref>, which would support 
                    a special kind of link that targets a specific string of text inside a page.
                    When clicking on such a link, the browser would scroll to, and then highlight,
                    the target text. This has been implemented in Chrome-based browsers (Chrome, 
                    Chromium and Edge) at the time of writing, but other browser producers are sceptical
                    with regard to the specification and worried about possible security implications.
                    The specification is subject to radical change. <gi>scrollToTextFragment</gi> is a 
                    boolean parameter that specifies whether you want to turn on this feature for 
                    browsers that support it. It depends on the availability of keyword-in-context 
                    strings, so <gi>createContexts</gi> must also be turned on to make it work. The
                    feature is automatically suppressed for browsers which do not support it. We recommend 
                    only using this feature on sites which are in steady development, so that if 
                    necessary it can be turned off, our the staticSearch implementation can be 
                    updated to take account of changes. For sites intended to remain unchanged or
                    archived for any length of time, this feature should be left turned off. It is
                    off by default.
                  </item>
                  
                  
                  <item><gi>verbose</gi> is a boolean which turns on/off detailed output messages
                  during the indexing process. You might set this to true if something is not working 
                  as expected and you need to do some debugging.</item>
                  
                  <item><gi>stopwordsFile</gi> is a string parameter containing the relative path
                  (from the config file) to a text file containing a list of stopwords that you want to
                  use for your site. A stopword is a word that will not be indexed, because it is too
                  common (<mentioned>the</mentioned>, <mentioned>a</mentioned>, <mentioned>you</mentioned>
                    and so on). The project has a built-in set of common stopwords for English, which 
                  we recommend you start from; you'll find it in <ident>xsl/english_stopwords.txt</ident>.
                  If your site is all about a person, a place or some other entity, then you might add 
                  their name to the stopwords list, because it will presumably appear on almost 
                  every page and it makes no sense to search for it. One way to find such terms is
                  to generate your index, then search for the largest JSON index files that are 
                  generated, to see if they might be too common to be useful as search terms.</item>
                  
                  <item><gi>dictionaryFile</gi> is the relative path to a file containing an English dictionary
                  (assuming your site is in English). This is used to check words during the indexing process,
                  and a report generated at the end will list all the terms in the site which do not appear 
                  in the dictionary. This is a useful way to find typos in your site. Again, there is a default 
                  dictionary in <ident>xsl/english_words.txt</ident> which you might copy and adapt.</item>
                  
                  <item><gi>indentJSON</gi> is a boolean parameter which controls whether the JSON
                  files generated for the index are indented or not. Indenting makes the files easier for a human
                  to read, if you need to understand them or debug them, but obviously it adds to their file 
                  size. </item>
                  
                  <item><gi>outputFolder</gi> is the name of a folder into which you would like to place
                  the JavaScript and JSON index files your site search. The default is <val>staticSearch</val>,
                  but if you would prefer something else, you can specify it here. You may also use this element 
                  if you are defining two different searches within the same site, so that their files are kept in 
                  different locations. The value must conform with
                  the <ref target="https://www.w3.org/TR/REC-xml/#dt-name">XML Name</ref> specification.</item>
                  
                </list>
                
                
              </div>
            </div>
          <div xml:id="specifyingRules">
            <head>Specifying rules (optional)</head>
            <p>The <gi>rules</gi> elements specifies a list of conditions (using the <gi>rule</gi> element) that tell the parser, using XPath statements in the <att>match</att> attribute, specific weights to assign to particular parts of each document. For instance, if you wanted all heading elements (<gi>h1</gi>, <gi>h2</gi>, etc) in documents to be given a greater weight and thus receive a higher score in the results, you can do so using a rule like so:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rules>
                  <rule weight="2" match="h1 | h2 | h3 | h4 | h5 | h6"/>
                </rules>
              </egXML>
              
              Since we're using XPath 3.0 and XSLT 3.0, this can also be simplified to:
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rules>
                  <rule weight="2" match="*[matches(local-name(),'^h\d+$')]"/>
                </rules>
              </egXML>
              (It is worth noting, however, the above example is unnecessary: all heading elements are given a weight of 2 by default, which is the only preconfigured weight in staticSearch.)
            </p>
            <p>The value of the <att>match</att> attribute is transformed in a XSLT template match attribute, and thus must follow the same rules (i.e. no complex rules like <code>p/ancestor::div</code>). See the <ref target="https://www.w3.org/TR/xslt-30/#dt-pattern">W3C XSLT Specification</ref> for further details on allowable pattern rules.</p>
            <p>Often, there will be elements that you want the tokenizer to ignore completely; for instance, if you have the same header in every document, then there's no reason to index its contents on every page. These elements can be ignored simply by using a <gi>rule</gi> and setting its weight to 0. For instance, if you want to remove the header and the footer from the search indexing process, you could write something like:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rule weight="0" match="footer | header"/>
              </egXML>
              Or if you want to remove XHTML anchor tags (<gi>a</gi>) whose text is identical to the URL specified in its <att>href</att>, you could do something like:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rule weight="0" match="a[@href=./text()]"/>
              </egXML>
            </p>
            <p>Note that the indexer does not tokenize any content in the <gi>head</gi> of the document (but as noted above, metadata can be configured into filters) and that all elements in the <gi>body</gi> of a document are considered tokenizable. However, common elements that you might want to exclude include:
              <list>
                <item><gi>script</gi></item>
                <item><gi>style</gi></item>
                <item><gi>code</gi></item>
              </list>
            </p>
          </div>
          <div xml:id="specifyingContexts">
            <head>Specifying contexts (optional)</head>
            <p>When the staticSearch creates the keywords-in-contexts (the "kwic" or "snippets") for each token, it does so by looking for the nearest block-level element that it can use as its context. Take, for instance, this unordered list:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <ul>
                  <li>Keyword-in-context search results. This is also configurable, since including contexts
                    increases the size of the index.</li>
                  <li>Search filtering using any metadata you like, allowing users to limit their search to specific
                    document types.</li>
                </ul>
              </egXML>
              Each <gi>li</gi> elements is, by default, a <term>context</term> element, meaning that the snippet generated for each token will not extend beyond the <gi>li</gi> element boundaries; in this case, if the <gi>li</gi> was not a context attribute, the term <q>search</q> would produce a context that looks something like:
              
              <eg>"...the size of the index.<hi style="font-weight:bold;">Search</hi> filtering using any metadata you like,..."</eg>
            </p>
            <p>Using the <gi>contexts</gi> element, you can control what elements operate as contexts. For instance, say a page contained a marginal note, encoded as a <gi>span</gi> in your document beside its point of attachment:<note place="foot">This example taken from Thomas S. Kuhn, <title level="m">The Structure of Scientific Revolutions</title> (50th anniversary edition), University of Chicago Press, 2012: p. 191.</note>
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <p>About that program I shall have nothing to say here,<span class="sidenote">Some information on this subject can be found in "Second Thoughts"</span> [...]
                </p>
              </egXML>
              Using CSS, the footnote might be alongside the text of the document in margin, or made into a clickable object using Javascript. However, since the tokenizer is unaware of any server-side processing, it understands the <gi>span</gi> as an inline element and assumes the <gi>p</gi> constitutes the context of the element. A search for <q>information</q> might then return:
              
              <eg>"...nothing to say here,Some <hi style="font-weight:bold;">information</hi> on this subject can be found...</eg>
              
              To tell the tokenizer that the <gi>span</gi> constitutes the context block for any of its token, use the <gi>context</gi> element with an <att>match</att> pattern:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <contexts>
                  <context match="span[contains-token(@class,'sidenote')]"/>
                </contexts>
              </egXML>
            </p>
            <p>You can also configure it the other way: if a <gi>div</gi>, which is by default a context block, should not be understood as a context block, then you can tell the parser to not consider it as such using <att>context</att> set to false:
              <egXML xmlns="http://www.tei-c.org/ns/Examples"> 
                <contexts>
                  <context match="div" context="false"/>
                </contexts>
              </egXML>
            </p>
            <p>The default contexts elements are:
              <list>
                <item><gi>body</gi></item>
                <item><gi>div</gi></item>
                <item><gi>blockquote</gi></item>
                <item><gi>p</gi></item>
                <item><gi>li</gi></item>
                <item><gi>section</gi></item>
                <item><gi>article</gi></item>
                <item><gi>nav</gi></item>
                <item><gi>h1</gi></item>
                <item><gi>h2</gi></item>
                <item><gi>h3</gi></item>
                <item><gi>h4</gi></item>
                <item><gi>h5</gi></item>
                <item><gi>h6</gi></item>
                <item><gi>td</gi></item>
              </list>
            </p>
          </div>
            <div xml:id="specifyingExclusions">
              <head>Specifying exclusions (optional)</head>
              
              <p>A complex site may have two or more search pages targetting
              specific types of document or content, each of which may need 
              its own particular search controls and indexes. This can easily 
              be achieved by specifying a different <gi>searchFile</gi> and 
              <gi>outputFolder</gi> in the configuration file for each search.</p>
              
              <p>For these searches to be different from each other, 
              they will also probably have different contexts and rules. For
              example, imagine that you are creating a special search page 
              that focuses only on the text describing images or figures 
              in your documents. You might do it like this:
              
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <rules> 
                    <rule match="text()[not(ancestor::div[@class='figure']or ancestor::title)]" weight="0"/>
                  </rules>
                </egXML>
              
              This specifies that all text nodes which are not part of the document title
              or descendants of <tag>div class="figure"</tag> should be ignored 
                (<att>weight</att>=<val>0</val>), so only your target nodes will be
                indexed.
              </p>
              
              
              <p>However, it's
              also likely that you will want to exclude certain features or 
              documents from a specialized search page, and this is done using
              the <gi>excludes</gi> section and its child <gi>exclude</gi> elements.</p>
              
              <p>Here is an example:
              
                <egXML xmlns="http://www.tei-c.org/ns/Examples">
                  <excludes>
                    <!-- We only index files which have illustrations in them. -->
                    <exclude type="index" 
                      match="html[not(descendant::meta[@name='Has illustration(s)'][@content='true'])]"/>
                    
                    <!-- We ignore the document type filter, 
                         because we are only indexing one type 
                         of document anyway. -->
                    <exclude type="filter" match="meta[@name='Document type']"/>
                    
                    <!-- We exclude the filter that specifies 
                         these documents because it's pointless. -->
                    <exclude type="filter" match="meta[@name='Has illustration(s)']"/>
                  </excludes>
                </egXML>
              
              Here we use <tag>exclude type="index"/</tag> to specify that all documents which do not contain 
                <tag>meta name="Has illustration(s)" content="true"/></tag>
                should be ignored. Then we use two <tag>exclude type="filter"/</tag> tags to 
                specify first that the <ident>Document type</ident> filter should be
                ignored (i.e. it should not appear on the search page), and second, that the 
                boolean filter <ident>Has illustrations(s)</ident> should also be excluded.
              </p>
              
              <p>Using exclusions, you can create multiple specialized search pages which have customized
              form controls within the same document collection. This is at the expense of additional
              disk space and build time, of course; each of these searches needs to be built separately.</p>
              
            </div>
          </div>
          
          <div xml:id="searchPage">
            <head>Creating a search page</head>
            <p>You'll obviously want the search page for your site to conform with the look and 
            feel of the rest of your site. You can create a complete HTML document (which must 
            of course also be well-formed XML, so it can be processed), containing all the site 
            components you need, and then the search build process will insert all the necessary
            components into that file. The only requirement is that the page contains one <gi>div</gi>
            element with the correct <att>id</att> attribute:
            
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
              <div id="staticSearch"> 
                [...content will be supplied by the build process...] 
              </div>
            </egXML>
              
              This <gi>div</gi> will be empty initially. The build process will find insert the search 
              controls, scripts and results <gi>div</gi> into this container. Then whenever you 
              rebuild the search for your site, the contents
              will be replaced. There is no need to make sure it's empty every time.</p>
              
              <p>The search process will also add a CSS <gi>style</gi> element to the <gi>head</gi> of the
              document:
              
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <style id="ssCss">
                  [...styles for search controls...]
                </style>
              </egXML>
              
              You can customize this CSS by providing your own CSS that overrides it, using <gi>style</gi>,
                or <gi>link</gi>, placed after it in the <gi>head</gi> element, or by replacing
              the inserted CSS after the build process.
            </p>
            
            <p>Note that once your file has been processed and all this content has been added,
            you can process it again at any time; there is no need to start every time with a clean,
            empty version of the search page.</p>
            
            <p>You can take a look at the <ident>test/search.html</ident> page for an example
            of how to configure the search page (although note that since this page has already 
            been processed, it has the CSS and the search controls embedded in it; it also has some
            additional JavaScript which we use for testing the search build results, which is not 
            necessary for your site).</p>
            
          </div>
          
          <div xml:id="searchBuildProcess">
            <head>Running the search build process</head>
            <p>Once you have configured your HTML and your configuration file, you're ready to 
            create a search index and a search page for your site. This requires that you run ant
            in the root folder of the staticSearch project that you have downloaded or cloned.</p>
            
            <p>Note: you will need Java and <ref target="https://ant.apache.org/">Apache Ant</ref> installed, 
              as well as <ref target="http://ant-contrib.sourceforge.net/">ant-contrib</ref>. </p>
            
            <p>Before running the search on your own site, you can test that your system is able
            to do the build by doing the (very quick) build of the test materials. If you simply run 
            the <ident>ant</ident> command, like this:</p>
            
            <eg>mholmes@linuxbox:~/Documents/staticSearch$ ant</eg>
            
            <p>you should see a build process proceed using the small test collection of
            documents, and at the end, a results page should open up giving you a report
            on what was done. If this fails, then you'll need to troubleshoot the problem 
            based on any error messages you see. (Do you have Java, Ant and ant-contrib installed and
            working on your system?).</p>
            
            <p>If the test succeeds, you can view the results by uploading the <ident>test</ident>
            folder and all its contents to a web server, or by running a local webserver on your 
            machine in that folder, using the 
              <ref target="https://docs.python.org/3.8/library/http.server.html">Python HTTP server</ref>
              or <ref target="https://www.php.net/manual/en/features.commandline.webserver.php">PHP's built-in web server</ref>.</p>
            
            <p>If the tests all work, then you're ready to build a search for your own site. Now you need
            to run the same command, but this time, tell the build process where to find your custom
            configuration file:</p>
            
            <eg>ant -DconfigFile=/home/mholmes/mysite/config_staticSearch.xml</eg>
            
            <p>The same process should run, and if it's successful, you should have a modified <ident>search.html</ident> page
            as well as a lot of index files in JSON format in your site HTML folder. Now you can test your own 
            search in the same ways suggested above.</p>
            
          </div>
          
        </div>
      <div xml:id="howDoesItWork">
        <head>How does it work?</head>
        <list>
          <item>Level: Advanced</item>
          <item>Last Updated: <date when="2020-07-17">17 July 2020</date></item>
        </list>
        <div xml:id="buildingTheIndex">
          <head>Building the index</head>
          <p>The tokenizing process first processes your configuration file to create an XSLT file
            with all your settings embedded in it. Next, it processes your document collection using
            those settings. Each document is tokenized, and then a separate JSON file is created for
            each distinct token found; this file contains links to each of the documents which contain
            that token, as well as keyword-in-context strings for the actual tokens. There will most
            likely be thousands of these files, but most of them are quite small. These constitute the
            textual index.</p>
          
          <p>In addition, separate JSON files are created for the list of document titles, and for your 
            stopword list if you have specified one. A single text file is also created containing
            all the unique terms in the collection, used when doing wildcard searches.</p>
          
          <p>Next, if you have specified search facets in your document headers, the processor
            will then create a separate JSON file for each of those search facets, consisting of a list 
            of the document identifiers for all documents which match the filters; so if some of your
            documents are specified as <soCalled>Illustrated</soCalled> and some not (true or false),
            a JSON file will be created for the <soCalled>Illustrated</soCalled> facet, with a list of 
            documents which are true for this facet, and a list of documents which are false.
          </p>
          
          <p>Finally, the template file you have created for the search page on your site will be 
          processed to add the required search controls and JavaScript to make the search work.</p>
        </div>
       
       <div xml:id="theSearchPage">
         <head>The search page</head>
         
         <p>In order to provide fast, responsive search results, the search page must download
         only the information it needs for each specific search. Obviously, if it were to download
         the entire collection of thousands of token files, the process would take forever. So when 
         you search for the word <mentioned>waiting</mentioned>, what happens is that the
         JavaScript stems that word, producing <mentioned>wait</mentioned>, then it downloads
         only the single file containing indexing information for that specific word, which is very 
         rapid. (If you are using a different stemmer, of course, then the token will be stemmed to
         a different output. If you are using the <ident>identity stemmer</ident>, then 
         the token will be unchanged; with the <ident>stripDiacritics</ident> pseudo-stemmer,
           all combining diacritics will be stripped from the search terms, as they are in 
           the corresponding index.)</p>
         
         <p>However, there is some information that is required for all or many searches. To display
           any results, the list of document titles must be downloaded, for example. A user may
         for instance use the search facets only, not searching for a particular word or phrase but just
         wanting a list of all the documents classified as <soCalled>Poems</soCalled>. This requires that
         the JSON file with information about that facet be downloaded. So there is some advantage 
         in having the JavaScript start downloading some of the essential files (titles, stopwords and
         so on) as soon as the page loads, and it also starts downloading the facet files in the
         background.</p>
         
         <p>At the same time, though, we don't want to clog up the connection downloading these files
         when the user may do a simple text search which doesn't depend on them, so these files
         are retrieved using a <soCalled>trickle</soCalled> approach, one at a time. Then if a search is
         initiated, all the files required for that specific search can be downloaded as fast as possible
         overriding the trickle sequence for files that are needed immediately.</p>
         
         <p>Once the user has been on the search page for any length of time, all ancillary files will 
         have been retrieved (assuming they weren't already cached by the browser), so the only 
         files required for any search are those for the actual text search terms; the response should
         therefore be even faster for later searches than for early ones.</p>
       </div>
      </div>
      <div xml:id="howDoI">
        <head><q>How do I...</q></head>
        <p>Below are some of the most common things you might want to do using staticSearch:</p>
        <table>
          <row>
            <cell>How do I get staticSearch to ignore large chunks of my document?</cell>
            <cell>Any element with a weight of 0 is ignored completely by the indexer, so add a <gi>rule</gi> for the element. So to ignore all elements with the class <val>ignoreThisElement</val>, you could do something like:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <rule weight="0" match="div[contains-token(@class,'ignoreThisElement')"/>
              </egXML></cell>
          </row>
          <row>
            <cell>How do I get staticSearch to ignore small inline bits and <emph>not</emph> have them in the KWIC?</cell>
            <cell>As above, you can use a <gi>rule</gi> with an <att>weight</att>=<val>0</val></cell>
          </row>
          <row>
            <cell>How do I get staticSearch to ignore an element, but retain its text in the KWIC?</cell>
            <cell>Here, you'll want to use the <gi>exclude</gi> function, which excludes the element from indexing, but doesn't remove it from the document itself. So, if you wanted to exclude all keyboard entry items (<gi>xh:kbd</gi>), but still have them in the KWIC, you could do something like:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <exclude match="kbd" type="index"/>
              </egXML>
            </cell>
          </row>
          <row>
            <cell>How can I get staticSearch to show debugging messages?</cell>
            <cell>Switch <gi>verbose</gi> to true in the configuration file:
              <egXML xmlns="http://www.tei-c.org/ns/Examples">
                <config xmlns="http://hcmc.uvic.ca/ns/staticSearch">
                  <params>
                    <!--....-->
                    <verbose>true</verbose>
                    <!--....-->
                  </params>
                  <!--Rules, etc-->
                </config>
              </egXML>
            </cell>
          </row>
          <row>
            <cell>How can I get staticSearch to jump straight to a specific hit in the document from a search result?</cell>
            <cell>The best way to do this is to ensure that <gi>linkToFragmentId</gi> is set to the <val>true</val> and that the
            input HTML contains ids at whatever level you think is most helpful. For instance, if possible, you could give each
            <gi>xhtml:p</gi> element an <att>id</att>, which would mean that each KWIC could be associated with the input document.</cell>
          </row>
        </table>
      </div>
      <div xml:id="projectsUsingSS">
        <head>Projects using staticSearch</head>
        <list>
          <item>Level: Basic</item>
          <item>Last Updated: <date when="2020-10-14">14 October 2020</date></item>
        </list>
        <table>
          <row role="label">
            <cell>Name</cell>
            <cell>staticSearch Version</cell>
            <cell>Search Page(s)</cell>
            <cell>Configuration file(s)</cell>
          </row>
          <row>
            <cell><ref target="https://mapoflondon.uvic.ca">The Map of Early Modern London</ref></cell>
            <cell>0.9</cell>
            <cell><ref target="https://mapoflondon.uvic.ca/search.htm">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/london/static/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://winnifredeatonarchive.org">The Winnifred Eaton Archive</ref></cell>
            <cell>1.0 (dev)</cell>
            <cell><ref target="https://winnifredeatonarchive.org/search.html">Search</ref></cell>
            <cell>
              <ref target="https://github.com/winnifredeatonarchive/wea_data/blob/09ae8660007a10e23e80e2f5769aec0bf1f919c6/code/staticSearch/config.xml">Github</ref></cell>
          </row>
          <row>
            <cell><ref target="https://johnkeats.uvic.ca/">Mapping Keat's Progress</ref></cell>
            <cell>1.0</cell>
            <cell><ref target="https://johnkeats.uvic.ca/search.html">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/keats/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://myndir.uvic.ca/">My Norse Digital Image Repository</ref></cell>
            <cell>1.0 (dev)</cell>
            <cell><ref target="https://myndir.uvic.ca/search.html">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/myndir/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://bcgenesis.uvic.ca/">The Colonial Despatches of BC and Vancouver Island</ref></cell>
            <cell>1.0 (dev)</cell>
            <cell><ref target="https://bcgenesis.uvic.ca/search.html">Search</ref></cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/coldesp/trunk/config_staticSearch.xml">SVN</ref></cell>
          </row>
          <row>
            <cell><ref target="https://dvpp.uvic.ca">Digital Victorian Periodical Poetry</ref></cell>
            <cell>1.0 (dev)</cell>
            <cell><ref target="https://dvpp.uvic.ca/search.html">Search</ref> (multiple searches with individual pages)</cell>
            <cell><ref target="https://hcmc.uvic.ca/svn/dvpp/">SVN</ref> (multiple configuration files)</cell>
          </row>
          <!--<row>
            <cell>Le mariage sous L'Ancien Régime (forthcoming)</cell>
            <cell/>
            <cell/>
            <cell/>
          </row>
          <row>
            <cell>Landscapes of Injustice (forthcoming)</cell>
            <cell/>
            <cell/>
            <cell/>
          </row>
          <row>
            <cell>Linked Early Modern Drama Online (forthcoming)</cell>
          </row>-->
        </table>
      </div>
      
      
    </body>
    <back>
      <div xml:id="schemaSpec">
        <head>Schema specification and tag documentation</head>
        
        <schemaSpec ident="staticSearch" start="config" ns="http://hcmc.uvic.ca/ns/staticSearch"
          defaultExceptions="http://hcmc.uvic.ca/ns/staticSearch">

          <moduleSpec ident="ss">
            <desc>Module for all of the staticSearch elements.</desc>
          </moduleSpec>

          <elementSpec ident="config" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>The root element for the Search Generator configuration file.</gloss>
            <content>
              <elementRef key="params"/>
              <elementRef key="rules" minOccurs="0"/>
              <elementRef key="contexts" minOccurs="0"/>
              <elementRef key="excludes" minOccurs="0"/>
            </content>
          </elementSpec>

          <elementSpec ident="params" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>Element containing most of the settings which enable the Generator to
            find the target website content and process it appropriately.</gloss>
            <content>
              <sequence preserveOrder="false">
                <elementRef key="searchFile"/>
                <elementRef key="versionFile" minOccurs="0"/>
                <elementRef key="stemmerFolder" minOccurs="0"/>
                <elementRef key="recurse"/>
                <elementRef key="linkToFragmentId" minOccurs="0"/>
                <elementRef key="scrollToTextFragment" minOccurs="0"/>
                <elementRef key="scoringAlgorithm" minOccurs="0"/>
                <elementRef key="phrasalSearch" minOccurs="0"/>
                <elementRef key="wildcardSearch" minOccurs="0"/>
                <elementRef key="createContexts" minOccurs="0"/>
                <elementRef key="maxKwicsToHarvest" minOccurs="0"/>
                <elementRef key="maxKwicsToShow" minOccurs="0"/>
                <elementRef key="totalKwicLength" minOccurs="0"/>
                <elementRef key="kwicTruncateString" minOccurs="0"/>
                <elementRef key="verbose" minOccurs="0"/>
                <elementRef key="stopwordsFile" minOccurs="0"/>
                <elementRef key="dictionaryFile" minOccurs="0"/>
                <elementRef key="replacementsFile" minOccurs="0"/>
                <elementRef key="indentJSON" minOccurs="0"/>
                <elementRef key="outputFolder" minOccurs="0"/>
              </sequence>
            </content>
          </elementSpec>

          <elementSpec ident="rules" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>The set of rules, expressed as XPath in <att>match</att>, that control weighting of search terms
              found in specific contexts.</gloss>
            <content>
              <elementRef key="rule" minOccurs="1" maxOccurs="unbounded"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="rule" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>A rule that specifies a document path as XPath in <att>match</att>, and provides weighting for search
              terms found in that context.</gloss>
            <classes>
              <memberOf key="att.match"/>
            </classes>
            <content>
              <empty/>
            </content>
            <attList>
              <attDef ident="weight" usage="req">
                <gloss>The weighting to give to a search token found in the context specified by the
                  <att>match</att> attribute. Set to 0 to completely suppress indexing for a
                  specific context, or greater than 1 to give stronger weighting.</gloss>
                <datatype>
                  <dataRef name="nonNegativeInteger"/>
                </datatype>
              </attDef>
            </attList>
          </elementSpec>

          <elementSpec ident="contexts" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>The set of contexts, expressed as XPath in <att>match</att>, that controls the identification of
            contexts for keyword-in-context fragments.</gloss>
            <content>
              <elementRef key="context" minOccurs="1" maxOccurs="unbounded"/>
            </content>
          </elementSpec>

          <elementSpec ident="context" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>A context definition, providing a <att>match</att> attribute that identifies the context,
              allowing keyword-in-context fragments to be bounded by a specific context.</gloss>
            <classes>
              <memberOf key="att.match"/>
              <memberOf key="att.labelled"/>
            </classes>
            <content>
              <empty/>
            </content>
            <attList>
              <attDef ident="context" usage="opt">
                <datatype>
                  <dataRef name="boolean"/>
                </datatype>
               </attDef>
            </attList>
          </elementSpec>
          
          <elementSpec ident="excludes" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>The set of exclusions, expressed as XPath in <att>match</att>, that control the subset of documents
            for a particular search.</gloss>
            <content>
              <elementRef key="exclude" minOccurs="1" maxOccurs="unbounded"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="exclude" ns="http://hcmc.uvic.ca/ns/staticSearch" module="ss">
            <gloss>An exclusion definition, which excludes either documents or filters as defined by an XPath in <att>match</att>.</gloss>
            <classes>
              <memberOf key="att.match"/>
            </classes>
            <content>
              <empty/>
            </content>
            <attList>
              <attDef ident="type" usage="req">
                <valList type="closed">
                  <valItem ident="index">
                    <gloss>Index exclusion</gloss>
                    <desc>An exclusion that specifies HTML fragment (which itself can be the root HTML element) to exclude from the document index.</desc>
                  </valItem>
                  <valItem ident="filter">
                    <gloss>Filter exclusion</gloss>
                    <desc>An exclusion that matches an HTML meta tag to exclude from the filter controls on the search page.</desc>
                  </valItem>
                </valList>
              </attDef>
            </attList>
          </elementSpec>

          <classSpec ident="att.match" module="ss" type="atts">
            <gloss>A class providing attributes that enable specification of document locations.</gloss>
            <attList>
              <attDef usage="req" ident="match">
                <gloss>An XPath equivalent to the @match attribute of an xsl:template, which
                  specifies a context in a document.</gloss>
                <datatype>
                  <dataRef name="string"/>
                </datatype>
              </attDef>
            </attList>
          </classSpec>
          
          <classSpec ident="att.labelled" module="ss" type="atts">
            <gloss>A class providing a label attribute that can be used to identify/describe contexts and other
              things which benefit from description.</gloss>
            <attList>
              <attDef ident="label" usage="opt">
                <gloss>A string identifier which may be descriptive.</gloss>
                <datatype>
                  <dataRef name="string"/>
                </datatype>
              </attDef>
            </attList>
          </classSpec>

          <elementSpec ident="searchFile" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The search file (aka page) that will be the primary access point for the staticSearch. Note
            that this page <emph>must</emph> be at the root of the collection directory.</gloss>
            <content>
              <dataRef name="anyURI"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="versionFile" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The relative path to a text file containing a single version identifier (such as 
              <val>1.5</val>, <val>123456</val>, or <val> 06ad419</val>). This will be used to create
            unique filenames for JSON resources, so that when a site is updated, so that the browser
            will not use cached versions of older index files.</gloss>
            <content>
              <dataRef name="anyURI"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="stemmerFolder" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The name of a folder inside the staticSearch <code>/stemmers/</code> folder, 
              in which the JavaScript and XSLT implementations
            of stemmers can be found. If left blank, then the staticSearch default English 
            stemmer will be used (<code>stemmers/en</code>).</gloss>
            <content>
              <dataRef name="NCName"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="scoringAlgorithm" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Which scoring algorithm to use. Default is "raw" (i.e. weighted counts)</gloss>
            <content>
              <valList type="closed">
                <valItem ident="raw">
                  <desc>raw score</desc>
                  <gloss>Default: Calculate the score based off of the weighted number of 
                    instances of a term in a text.</gloss>
                </valItem>
                <valItem ident="tf-idf">
                  <gloss>Calculate the score based off of the tf-idf scoring algorithm.</gloss>
                </valItem>
              </valList>
            </content>
          </elementSpec>
          
          <elementSpec ident="recurse" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether to recurse into subdirectories of the collection directory or
              not.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
      
          <elementSpec ident="createContexts" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether to include keyword-in-context extracts in the index. This increases the
              size of the index considerably, but it allows for more user-friendly search results,
              as well as phrasal searches.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="linkToFragmentId" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether to link keyword-in-context extracts to the nearest id in the document. Default is true.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="scrollToTextFragment" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>WARNING: Experimental technology. This turns on a feature currently only 
            supported by a subset of browsers, enabling links from keyword-in-context results
            directly to the specific text string in the target document.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="totalKwicLength" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>If <gi>createContexts</gi> is set to true, then this parameter controls how long
              the contexts will be.</gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="maxKwicsToHarvest" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>This controls the maximum number of keyword-in-context extracts that will be
              stored for each term. If <gi>phrasalSearch</gi> is set to true, this parameter is
              ignored, because phrasal searches will only work properly if all contexts are
              stored.</gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="maxKwicsToShow" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>This controls the maximum number of keyword-in-context extracts that will be shown
              in the search page for each hit document returned.</gloss>
            <content>
              <dataRef name="nonNegativeInteger"/>
            </content>
          </elementSpec>

          <elementSpec ident="kwicTruncateString" module="ss"
            ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The string that will be used to signal ellipsis at the beginning and end of a
              keyword-in-context extract. Conventionally three periods, or an ellipsis
              character.</gloss>
            <content>
              <textNode/>
            </content>
          </elementSpec>

          <elementSpec ident="indentJSON" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether or not to indent code in the JSON index files. Indenting increases the
              file size, but it can be useful if you need to read the files for debugging
              purposes.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
          
          
          <elementSpec ident="phrasalSearch" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether or not to support phrasal searches. If this is true, then the <gi>maxContexts</gi>
            setting will be ignored, because all contexts are required to properly support phrasal search.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
          
          
          <elementSpec ident="wildcardSearch" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Whether or not to support wildcard searches. Note that wildcard searches are
            more effective when phrasal searching is also turned on, because the contexts 
            available for phrasal searches are also used to provide wildcard results.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
          
          <elementSpec ident="verbose" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>Turns on more detailed reporting during the indexing process.</gloss>
            <content>
              <dataRef name="boolean"/>
            </content>
          </elementSpec>
          <elementSpec ident="stopwordsFile" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The location of a text file containing a list of stopwords (words to be ignored
            when indexing). These are typically words too common to be worth searching for, but 
            every site will also have some specific terms which are used so widely across the site
            that they should be suppressed to control the index size. The list should be in plain text
            with one word per line.</gloss>
            <content>
              <dataRef name="anyURI"/>
            </content>
          </elementSpec>
          <elementSpec ident="dictionaryFile" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The location of a dictionary file (one word per line) which will be used to check
            tokens when indexing.</gloss>
            <content>
              <dataRef name="anyURI"/>
            </content>
          </elementSpec>
          <elementSpec ident="outputFolder" module="ss" ns="http://hcmc.uvic.ca/ns/staticSearch">
            <gloss>The name of the output folder into which the index data and JavaScript will 
              be placed in the site search. This should conform with the 
              <ref target="https://www.w3.org/TR/REC-xml/#dt-name">XML Name</ref> specification.</gloss>
            <content>
              <dataRef name="NCName"/>
            </content>
          </elementSpec>
        </schemaSpec>
      </div>
    </back>
  </text>
</TEI>
