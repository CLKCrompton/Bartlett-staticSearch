<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:hcmc="http://hcmc.uvic.ca/ns/staticSearch"
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"
    xmlns:j="http://www.w3.org/2005/xpath-functions"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    xmlns:array="http://www.w3.org/2005/xpath-functions/array"
    exclude-result-prefixes="#all"
    xpath-default-namespace="http://www.w3.org/1999/xhtml"
    version="3.0">
    <xd:doc scope="stylesheet">
        <xd:desc>
            <xd:p><xd:b>Created on:</xd:b> Sept 2, 2021</xd:p>
            <xd:p><xd:b>Authors:</xd:b> Joey Takeda and Martin Holmes</xd:p>            
            <xd:p>This transformation creates a concordance for the document collection.</xd:p>
        </xd:desc>
    </xd:doc>
    
    <!--**************************************************************
       *                                                            *
       *                         Includes                           *
       *                                                            *
       **************************************************************-->  
    <xd:doc>
        <xd:desc>Include the generated config file.</xd:desc>
    </xd:doc>
    <xsl:include href="config.xsl"/>
 
    <xd:doc>
        <xd:desc>Include the functions</xd:desc>
    </xd:doc>
    <xsl:include href="functions.xsl"/>
   
    <!--**************************************************************
       *                                                            *
       *                        Parameters                          *
       *                                                            *
       **************************************************************-->  
    <xd:doc>
        <xd:desc>Parameter for whether the concordance should be ascending or descending.</xd:desc>
    </xd:doc>
    <xsl:param name="ascending" select="'false'" as="xs:string"/>
    
    
    <!--**************************************************************
       *                                                            *
       *                         Variables                          *
       *                                                            *
       **************************************************************-->  
    
    <xd:doc>
        <xd:desc><xd:ref name="stemsDir" type="variable">$stemsDir</xd:ref> is the directory
        that contains all of the stems generated by json.xsl.</xd:desc>
    </xd:doc>
    <xsl:variable name="stemsDir" select="$outDir || '/stems'" as="xs:string"/>
    
    <xd:doc>
        <xd:desc><xd:ref name="stemToVariantsMap" type="variable">$stemToVariantsMap</xd:ref> is
        a map that collects all of the stem JSON files and compiles them into a smaller map to
        use as the basis for the concordance. The map is structured similarly to the input JSON, but removes
        most of the data, leaving only the stem id, each variant, the documents that contain that variant, and how
        many times that variant appears in the document.</xd:desc>
        <xd:return>An object like so:
        {
            'stem': {
                'variant':
                    {
                        'docId': numberOfContextsForThisVariant
                    }
            }
        }
        </xd:return>
    </xd:doc>
    <xsl:variable name="stemToVariantsMap" as="map(xs:string, map(xs:string, map(xs:string, xs:integer)))">
        <xsl:message>Processing JSON files...</xsl:message>
        <xsl:map>
            <xsl:for-each select="uri-collection($stemsDir || '?select=*.json;recurse=no')">
             
                <!--Parse the JSON into a XPath map-->
                <xsl:variable name="thisJson" select="parse-json(unparsed-text(.))" as="map(*)"/>
                <!--Add an entry for each stem-->
                <xsl:map-entry key="$thisJson?stem">
                    <xsl:map>
                        <!--Group all of the instances (i.e. documents) by form by flattening
                            the instances into a sequence of maps, and then returning all of the forms
                            that are contained by the array of contexts contained by each instance-->
                        <xsl:for-each-group select="array:flatten($thisJson?instances)" 
                            group-by="for $ctx in array:flatten(.?contexts) return $ctx?form">
                            <xsl:variable name="currForm" select="current-grouping-key()" as="xs:string"/>
                            <xsl:variable name="currInstances" select="current-group()" as="map(*)*"/>
                            <!--Create an entry for the form-->
                            <xsl:map-entry key="$currForm">
                                <xsl:map>
                                    <!--Now iterate through the instance maps that contain that form-->
                                    <xsl:for-each select="$currInstances">
                                        <xsl:variable name="currInstance" select="." as="map(*)"/>
                                        <!--Retrieve the document id-->
                                        <xsl:variable name="currDocId" select="$currInstance?docId" as="xs:string"/>
                                        <!--Get the set of contexts (as a sequence of maps)-->
                                        <xsl:variable name="currContexts"
                                            select="array:flatten($currInstance?contexts)" as="map(*)*"/>
                                        <!--And return the count-->
                                        <xsl:variable name="count" 
                                            select="count($currContexts[.?form = $currForm])" as="xs:integer"/>
                                        
                                        <xsl:map-entry key="$currDocId" select="$count"/>
                                    </xsl:for-each>
                                </xsl:map>
                            </xsl:map-entry>
                        </xsl:for-each-group>
                    </xsl:map>
                </xsl:map-entry>
            </xsl:for-each>
        </xsl:map>
    </xsl:variable>
    
    <xd:doc>
        <xd:desc><xd:ref name="allStems" type="variable">$allStems</xd:ref> is the string sequence
        of all of the stems retrieved (from the stem-variants map)</xd:desc>
    </xd:doc>
    <xsl:variable name="allStems" select="map:keys($stemToVariantsMap)" as="xs:string+"/>
    
    <xd:doc>
        <xd:desc><xd:ref name="sortedStems" type="variable">$sortedStems</xd:ref> is the sequence
        of stems sorted on the number of instances. The stem value is passed to the higher-order function
        and multiplied by a factor to determine if we should sort it ascending or not.</xd:desc>
    </xd:doc>
    <xsl:variable name="sortedStems"
        select="sort($allStems, (), function($stem){
                (: Determine whether we need to sort asc or desc :)
                let $factor := if ($ascending = 'true') then 1 else -1
                (: And then return the product :)
                return $factor * hcmc:getTotalInstances($stem)
            })"
        as="xs:string+"/>
    
    <xd:doc>
        <xd:desc><xd:ref name="allStems" type="variable">$stemCount</xd:ref> is the count of stems
        (aka the size of the stemVariantsMap).</xd:desc>
    </xd:doc>
    <xsl:variable name="stemCount" select="map:size($stemToVariantsMap)" as="xs:integer"/>
    
    <!--**************************************************************
       *                                                            *
       *                         Templates                          *
       *                                                            *
       **************************************************************-->  

    <xd:doc>
        <xd:desc>Documentation</xd:desc>
    </xd:doc>
    <xsl:template name="makeConcordance">
        <xsl:message>Found <xsl:value-of select="$stemCount"/> stems...</xsl:message>
        <xsl:call-template name="makeConcordanceJSON"/>
        <xsl:call-template name="makeConcordanceHTML"/>
    </xsl:template>
    
    <xd:doc>
        <xd:desc/>
    </xd:doc>
    <xsl:template name="makeConcordanceJSON">
        <xsl:result-document href="{$outDir}/concordance.json" method="json">
            <xsl:message>Creating <xsl:value-of select="j:current-output-uri()"/></xsl:message>
            <xsl:sequence select="$stemToVariantsMap"/>
        </xsl:result-document>
    </xsl:template>
    
    <xd:doc>
        <xd:desc/>
    </xd:doc>
    <xsl:template name="makeConcordanceHTML">
        <xsl:result-document href="{$outDir}/concordance.html" method="xhtml" encoding="UTF-8" normalization-form="NFC"
            exclude-result-prefixes="#all" omit-xml-declaration="yes" html-version="5.0">
            <xsl:message>Creating <xsl:value-of select="j:current-output-uri()"/></xsl:message>
            <html>
                <head>
                    <title>Static Search Concordance: <xsl:value-of select="$collectionDir"/></title>
                    <link rel="stylesheet" href="ssReports.css"/>
                </head>
                <body>
                    <div>
                        <xsl:call-template name="makeConcordanceTable"/>
                    </div>
                </body>
            </html>
        </xsl:result-document>       
    </xsl:template>

    <xd:doc>
        <xd:desc/>
        <xd:param name="stemsToUse"/>
    </xd:doc>
    <xsl:template name="makeConcordanceTable">
        <xsl:param name="stemsToUse" select="$sortedStems" as="xs:string+"/>
        <table>
            <thead>
                <tr>
                    <th>Stem</th>
                    <th>Total Instances</th>
                    <th>Total Variants</th>
                    <th>Variant List (# docs)</th>
                    <th>Number of Documents</th>
                    <th>Average use per document</th>
                </tr>
            </thead>
            <tbody>
                <xsl:for-each select="$stemsToUse">
                    <xsl:variable name="stem" select="." as="xs:string"/>
                    <xsl:variable name="currMap" select="map:get($stemToVariantsMap, $stem)" as="map(*)"/>
                    <xsl:variable name="variants" select="map:keys($currMap)" as="xs:string+"/>
                    <xsl:variable name="variantsTotal" select="map:size($currMap)" as="xs:integer"/>
                    <xsl:variable name="total" select="hcmc:getTotalInstances($stem)" as="xs:integer"/>
                    <xsl:variable name="docsTotal" select="hcmc:getTotalDocs($stem)" as="xs:integer"/>
                    <tr>
                        <td><xsl:value-of select="$stem"/></td>
                        <td><xsl:value-of select="$total"/></td>
                        <td><xsl:value-of select="$variantsTotal"/></td>
                        <td>
                            <ul>
                                <xsl:for-each select="$variants">
                                    <xsl:sort select="map:size($currMap(.))" order="descending"/>
                                    <li><xsl:value-of select="."/> (<xsl:value-of select="map:size($currMap(.))"/>)</li>
                                </xsl:for-each>
                            </ul>
                        </td>
                        <td>
                            <xsl:value-of select="$docsTotal"/>
                        </td>
                        <td>
                            <xsl:value-of 
                                select="format-number($total div $docsTotal,'#.##')"/>
                        </td>
                    </tr>
                </xsl:for-each>
            </tbody>
        </table>
    </xsl:template>
    
 
    
    <xd:doc>
        <xd:desc/>
        <xd:param name="stem"/>
    </xd:doc>
    <xsl:function name="hcmc:getTotalInstances" new-each-time="no">
        <xsl:param name="stem" as="xs:string"/>
        <xsl:variable name="stemMap" select="$stemToVariantsMap($stem)" as="map(*)"/>
        <xsl:variable name="variants" select="map:keys($stemMap)" as="xs:string+"/>
        <xsl:variable name="total" as="xs:integer"
            select="sum(for $variant in $variants return
                        let $vMap := $stemMap($variant),
                        $docs := map:keys($vMap)
                        return 
                            for $doc in $docs return $vMap($doc))"/>
        <xsl:sequence select="$total"/>
    </xsl:function>
    
    <xd:doc>
        <xd:desc/>
        <xd:param name="stem"/>
    </xd:doc>
    <xsl:function name="hcmc:getTotalDocs" as="xs:integer">
        <xsl:param name="stem" as="xs:string"/>
        <xsl:variable name="stemMap" select="$stemToVariantsMap($stem)" as="map(*)"/>
        <xsl:variable name="variants" select="map:keys($stemMap)" as="xs:string+"/>
        <xsl:variable name="allDocs" 
            select="for $variant in $variants return map:keys($stemMap($variant))" as="xs:string+"/>
        <xsl:variable name="distinctDocs" select="distinct-values($allDocs)" as="xs:string+"/>
        <xsl:sequence select="count($distinctDocs)"/>
    </xsl:function>
    
</xsl:stylesheet>